name: DevOps CI/CD Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

env:
  DOCKER_IMAGE: fatimakz/todo-spring-boot-app
  AWS_REGION: us-east-1
  EKS_CLUSTER_NAME: todo-app-cluster

jobs:
  # Stage 1: Build & Test
  build-and-test:
    name: Build and Test
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
    
    - name: Set up JDK 8
      uses: actions/setup-java@v3
      with:
        java-version: '8'
        distribution: 'temurin'
        cache: maven
    
    - name: Build with Maven
      run: mvn clean package -DskipTests
    
    - name: Run tests
      run: mvn test
    
    - name: Upload artifact
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: todo-app-jar
        path: target/*.war
        if-no-files-found: warn

  # Stage 2: Security & Linting
  security-scan:
    name: Security Scanning
    runs-on: ubuntu-latest
    needs: build-and-test
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
    
    - name: Set up JDK 8
      uses: actions/setup-java@v3
      with:
        java-version: '8'
        distribution: 'temurin'
    
    - name: Run OWASP Dependency Check
      run: |
        mvn org.owasp:dependency-check-maven:check -DskipTests || true
    
    - name: Lint Dockerfile
      uses: hadolint/hadolint-action@v3.1.0
      with:
        dockerfile: Dockerfile
        ignore: DL3008,DL3009
    
    - name: Scan Docker image with Trivy
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'config'
        scan-ref: '.'
        format: 'sarif'
        output: 'trivy-results.sarif'

  # Stage 3: Docker Build and Push
  docker-build-push:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    needs: security-scan
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v2
    
    - name: Login to Docker Hub
      uses: docker/login-action@v2
      with:
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}
    
    - name: Build and push Docker image
      uses: docker/build-push-action@v4
      with:
        context: .
        push: true
        tags: |
          ${{ env.DOCKER_IMAGE }}:latest
          ${{ env.DOCKER_IMAGE }}:${{ github.sha }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  # Stage 4: Terraform Infrastructure Provisioning
  terraform-apply:
    name: Provision Infrastructure with Terraform
    runs-on: ubuntu-latest
    needs: docker-build-push
    if: github.ref == 'refs/heads/main'
    
    defaults:
      run:
        working-directory: ./infra
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
    
    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v2
      with:
        terraform_version: 1.5.0
    
    - name: Terraform Init
      run: terraform init
    
    - name: Terraform Format Check
      run: terraform fmt -check -recursive || echo "Some files need formatting, continuing..."
      continue-on-error: true
    
    - name: Terraform Validate
      run: terraform validate
    
    - name: Terraform Plan
      id: plan
      run: |
        terraform plan -out=tfplan -detailed-exitcode
        echo "exitcode=$?" >> $GITHUB_OUTPUT
      env:
        TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}
      continue-on-error: true
    
    - name: Check if changes needed
      id: check-changes
      run: |
        if [ "${{ steps.plan.outputs.exitcode }}" == "2" ]; then
          echo "changes_needed=true" >> $GITHUB_OUTPUT
        else
          echo "changes_needed=false" >> $GITHUB_OUTPUT
        fi
    
    - name: Terraform Apply
      if: steps.check-changes.outputs.changes_needed == 'true'
      run: terraform apply -auto-approve tfplan
      env:
        TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}
    
    - name: Skip Terraform Apply
      if: steps.check-changes.outputs.changes_needed == 'false'
      run: echo "No infrastructure changes needed, skipping apply..."
    
    - name: Save Terraform Outputs
      id: tf-outputs
      if: always()
      run: |
        set +e
        RDS_ENDPOINT=$(terraform output -raw rds_endpoint 2>&1 | grep -v "‚ï∑" | grep -v "‚îÇ" | grep -v "‚ïµ" | head -n1)
        EKS_CLUSTER=$(terraform output -raw eks_cluster_name 2>&1 | grep -v "‚ï∑" | grep -v "‚îÇ" | grep -v "‚ïµ" | head -n1)
        
        if [ -z "$RDS_ENDPOINT" ] || [[ "$RDS_ENDPOINT" == *"Error"* ]]; then
          RDS_ENDPOINT="todo-app-mysql.capkocm88jfm.us-east-1.rds.amazonaws.com:3306"
        fi
        
        if [ -z "$EKS_CLUSTER" ] || [[ "$EKS_CLUSTER" == *"Error"* ]]; then
          EKS_CLUSTER="todo-app-cluster"
        fi
        
        echo "rds_endpoint=$RDS_ENDPOINT" >> "$GITHUB_OUTPUT"
        echo "eks_cluster_name=$EKS_CLUSTER" >> "$GITHUB_OUTPUT"
        set -e

  # Stage 5: Deploy to Kubernetes with Ansible
  ansible-deploy:
    name: Deploy Application with Ansible
    runs-on: ubuntu-latest
    needs: terraform-apply
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
    
    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Install kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.29.0'
    
    - name: Install Ansible
      run: |
        sudo apt-get update
        sudo apt-get install -y ansible
    
    - name: Configure kubectl for EKS
      run: |
        aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}
    
    - name: Run Ansible Playbook - Configure Environment
      run: |
        cd ansible
        ansible-playbook -i hosts.ini playbook.yaml
    
    - name: Run Ansible Playbook - Deploy Application
      run: |
        cd ansible
        ansible-playbook -i hosts.ini deploy-app.yaml

  # Stage 6: Post-Deploy Smoke Tests
  smoke-tests:
    name: Post-Deployment Smoke Tests
    runs-on: ubuntu-latest
    needs: ansible-deploy
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
    
    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Install kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.29.0'
    
    - name: Configure kubectl
      run: |
        aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}
    
    - name: Wait for pods to be ready
      run: |
        kubectl wait --for=condition=ready pod -l app=todo-app -n todo-app --timeout=300s
    
    - name: Check pod status
      run: |
        kubectl get pods -n todo-app
        kubectl get svc -n todo-app
    
    - name: Get LoadBalancer URL
      id: get-url
      run: |
        LB_URL=$(kubectl get svc todo-app-service -n todo-app -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
        echo "LoadBalancer URL: http://$LB_URL"
        echo "lb_url=$LB_URL" >> $GITHUB_OUTPUT
    
    - name: Wait for LoadBalancer to be ready
      run: |
        echo "Waiting for LoadBalancer to be accessible..."
        sleep 60
    
    - name: Test application endpoint
      run: |
        LB_URL="${{ steps.get-url.outputs.lb_url }}"
        for i in {1..10}; do
          if curl -f -s -o /dev/null -w "%{http_code}" "http://$LB_URL" | grep -q "200\|302"; then
            echo "‚úÖ Application is accessible!"
            curl -I "http://$LB_URL"
            exit 0
          fi
          echo "Attempt $i: Waiting for application..."
          sleep 10
        done
        echo "‚ùå Application is not accessible"
        exit 1
    
    - name: Check application logs
      if: always()
      run: |
        kubectl logs -n todo-app -l app=todo-app --tail=50

  # Summary Job
  pipeline-summary:
    name: Pipeline Summary
    runs-on: ubuntu-latest
    needs: [build-and-test, security-scan, docker-build-push, terraform-apply, ansible-deploy, smoke-tests]
    if: always()
    
    steps:
    - name: Pipeline Status
      run: |
        echo "================================================"
        echo "üöÄ DevOps Pipeline Execution Summary"
        echo "================================================"
        echo "‚úÖ Build & Test: ${{ needs.build-and-test.result }}"
        echo "‚úÖ Security Scan: ${{ needs.security-scan.result }}"
        echo "‚úÖ Docker Build: ${{ needs.docker-build-push.result }}"
        echo "‚úÖ Terraform: ${{ needs.terraform-apply.result }}"
        echo "‚úÖ Ansible Deploy: ${{ needs.ansible-deploy.result }}"
        echo "‚úÖ Smoke Tests: ${{ needs.smoke-tests.result }}"
        echo "================================================"
